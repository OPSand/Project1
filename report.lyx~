#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing double
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Project 1, FYS 3150 / 4150, fall 2013
\end_layout

\begin_layout Author
Nathalie Bonatout and Odd Petter Sand
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In this project we will solve the one-dimensional Poissson equation with
 Dirichlet boundary conditions by rewriting it as a set of linear equations.
\end_layout

\begin_layout Standard
To be more explicit we will solve the equation 
\begin_inset Formula 
\[
-u''(x)=f(x),\hspace{0.5cm}x\in(0,1),\hspace{0.5cm}u(0)=u(1)=0.
\]

\end_inset

and we define the discretized approximation to 
\begin_inset Formula $u$
\end_inset

 as 
\begin_inset Formula $v_{i}$
\end_inset

 with grid points 
\begin_inset Formula $x_{i}=ih$
\end_inset

 in the interval from 
\begin_inset Formula $x_{0}=0$
\end_inset

 to 
\begin_inset Formula $x_{n+1}=1$
\end_inset

.
 The step length or spacing is defined as 
\begin_inset Formula $h=1/(n+1)$
\end_inset

.
 We have then the boundary conditions 
\begin_inset Formula $v_{0}=v_{n+1}=0$
\end_inset

.
 We approximate the second derivative of 
\begin_inset Formula $u$
\end_inset

 with 
\begin_inset Formula 
\[
-\frac{v_{i+1}+v_{i-1}-2v_{i}}{h^{2}}=f_{i}\hspace{0.5cm}\mathrm{for}\hspace{0.1cm}i=1,\dots,n,
\]

\end_inset

where 
\begin_inset Formula $f_{i}=f(x_{i})$
\end_inset

.
\end_layout

\begin_layout Standard
(Author's note: This text, and the text introducing the various exercises,
 is taken from the project description provided at the course website.)
\end_layout

\begin_layout Section
Exercises
\end_layout

\begin_layout Subsection
Exercise a)
\end_layout

\begin_layout Standard
We start with the given equation
\end_layout

\begin_layout Standard
\begin_inset Formula $-\frac{v_{i-1}-2v_{i}+v_{i+1}}{h^{2}}=f_{i}$
\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $i\in[1,n]\cap\mathbb{N}$
\end_inset

 and 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

.
 We will assume that 
\begin_inset Formula $n\geqslant3$
\end_inset

 and that 
\begin_inset Formula $v_{0}=v_{n+1}=0$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $-v_{i-1}+2v_{i}-v_{i+1}=h^{2}f_{i}\equiv\widetilde{b}_{i}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left[\begin{array}{ccc}
-1 & 2 & -1\end{array}\right]\left[\begin{array}{c}
v_{i-1}\\
v_{i}\\
v_{i+1}
\end{array}\right]=\widetilde{b}_{i}$
\end_inset


\end_layout

\begin_layout Standard
Now we expand these vectors from 3 elements to 
\begin_inset Formula $n$
\end_inset

 elements.
 Note that the 
\begin_inset Formula $i$
\end_inset

th element of the row vector should be 2 and the 
\begin_inset Formula $i$
\end_inset

th element of the column vector should be 
\begin_inset Formula $v_{i}$
\end_inset

 after the expansion:
\end_layout

\begin_layout Standard
\begin_inset Formula $\left[\begin{array}{ccccccc}
0 & \cdots & -1 & 2 & -1 & \cdots & 0\end{array}\right]\left[\begin{array}{c}
v_{1}\\
\vdots\\
v_{i-1}\\
v_{i}\\
v_{i+1}\\
\vdots\\
v_{n}
\end{array}\right]=\widetilde{b}_{i}$
\end_inset


\end_layout

\begin_layout Standard
Note that in the row vector 2 can very well be the first or last element,
 in which case the preceding presentation can be a little misleading.
 We further recognize the row vector as the 
\begin_inset Formula $i$
\end_inset

th row of the 
\begin_inset Formula $n\times n$
\end_inset

 matrix 
\begin_inset Formula $\mathbf{A}$
\end_inset

 (defined such that 
\begin_inset Formula $A_{ij}=2\delta_{ij}-\delta_{i(j-1)}-\delta_{i(j+1)}$
\end_inset

 ) and get the inner product
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathbf{A}_{i}\cdot\mathbf{v}=\widetilde{b}_{i}$
\end_inset


\end_layout

\begin_layout Standard
and remembering that 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $i\in[1,n]$
\end_inset

, by the definition of matrix multiplication
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathbf{A}\mathbf{v}=\mathbf{\widetilde{b}}$
\end_inset


\end_layout

\begin_layout Standard
which is what we wanted to show.
\end_layout

\begin_layout Subsection
Exercise b)
\end_layout

\begin_layout Standard
The algorithm we will use is as follows: First we do forward subsitution
 by subtracting from the current row a multiple of the row before it.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $A_{i}=A_{i}-x_{i}A_{i-1}$
\end_inset


\end_layout

\begin_layout Standard
Here, 
\begin_inset Formula $x_{i}$
\end_inset

 is the factor that cause the term 
\begin_inset Formula $a_{i}$
\end_inset

 to cancel out.
 Before the first step, the rows 
\begin_inset Formula $i-1$
\end_inset

 and 
\begin_inset Formula $i$
\end_inset

 look like this (the * indicates a value that has been changed by the algoritm)
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{array}{ccccccc}
\cdots & 0 & b_{i-1}^{*} & c_{i-1} & 0 & 0 & \cdots\\
\cdots & 0 & a_{i} & b_{i} & c_{i} & 0 & \cdots
\end{array}$
\end_inset


\end_layout

\begin_layout Standard
and our goal is that it look like this after the forward substitution
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{array}{ccccccc}
\cdots & 0 & b_{i-1}^{*} & c_{i-1} & 0 & 0 & \cdots\\
\cdots & 0 & 0 & b_{i}^{*} & c_{i} & 0 & \cdots
\end{array}$
\end_inset


\end_layout

\begin_layout Standard
(note that 
\begin_inset Formula $c_{i}$
\end_inset

 is unchanged).
 When we reach the bottom, we do a backward subsitution by adding to the
 current row a multiple of the row below it and then dividing the last element
 by itself to make the last element equal to 1:
\end_layout

\begin_layout Standard
\begin_inset Formula $A_{i}=A_{i}-c_{i}A_{i+1}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $A_{i}=\frac{A_{i}}{b_{i}^{*}}$
\end_inset


\end_layout

\begin_layout Standard
That is to say, we go from
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{array}{cccccc}
\cdots & 0 & b_{i}^{*} & c_{i} & 0 & \cdots\\
\cdots & 0 & 0 & 1 & 0 & \cdots
\end{array}$
\end_inset


\end_layout

\begin_layout Standard
to
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{array}{cccccc}
\cdots & 0 & 1 & 0 & 0 & \cdots\\
\cdots & 0 & 0 & 1 & 0 & \cdots
\end{array}$
\end_inset


\end_layout

\begin_layout Standard
Naturally, we also have to do equivalent operations on the vector 
\series bold

\begin_inset Formula $\mathbf{\widetilde{b}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 on the other side of the equation.
 We will not calculate any unnecessary values, i.e.
 values that will not be used by the program later on.
 Hence the algoritm looks like this (number of flops in parantheses):
\end_layout

\begin_layout Standard
For 
\begin_inset Formula $i$
\end_inset

 : 
\begin_inset Formula $2\longrightarrow n$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $x_{i}=\frac{a_{i}}{b_{i-1}^{*}}\;$
\end_inset

 (
\begin_inset Formula $n$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $b_{i}=b_{i}-x_{i}c_{i-1}\;$
\end_inset

(
\begin_inset Formula $2n$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\widetilde{b}_{i}=\widetilde{b}_{i}-x_{i}\widetilde{b}_{i-1}\;$
\end_inset

(
\begin_inset Formula $2n$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $\widetilde{b}_{n}=\frac{\widetilde{b}_{n}}{b_{n}}\;(1)$
\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset Formula $i$
\end_inset

 : 
\begin_inset Formula $n-1\longrightarrow1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\widetilde{b}_{i}=\widetilde{b}_{i}-c_{i}\widetilde{b}_{i+1}\;$
\end_inset

(
\begin_inset Formula $2n$
\end_inset

)
\end_layout

\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\widetilde{b}_{i}=\frac{\widetilde{b}_{i}}{b_{i}}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\;$
\end_inset

 (
\begin_inset Formula $n$
\end_inset

)
\end_layout

\begin_layout Standard
This makes the total running time of the algorihm 
\begin_inset Formula $8n$
\end_inset

 (actually, it is 
\begin_inset Formula $8(n-1)$
\end_inset

, but we are mostly concerned with the performance for large 
\begin_inset Formula $n$
\end_inset

, where 
\begin_inset Formula $n\approx n-1$
\end_inset

).
\end_layout

\begin_layout Standard
If the matrix is symmetric, so that 
\begin_inset Formula $a_{i}=c_{i-1},$
\end_inset

 then 
\begin_inset Formula $x_{i}c_{i-1}=\frac{a_{i}^{2}}{b_{i-1}^{*}}$
\end_inset

.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $a_{i}=c_{i-1}=k$
\end_inset

 for all 
\begin_inset Formula $i$
\end_inset

, we have a special case where 
\begin_inset Formula $k=\pm1$
\end_inset

.
 Then 
\begin_inset Formula $x_{i}=\pm\frac{1}{b_{i-1}^{*}}$
\end_inset

, 
\begin_inset Formula $k^{2}=1$
\end_inset

 and 
\begin_inset Formula $x_{i}c_{i-1}=\frac{1}{b_{i-1}^{*}}=-x_{i}\equiv y_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Furthermore, 
\begin_inset Formula $c_{i}\widetilde{b}_{i+1}=k\widetilde{b}_{i+1}=\mp\widetilde{b}_{i+1}$
\end_inset

 (note: opposite of the sign of 
\begin_inset Formula $k$
\end_inset

).
 The algorithm will then look like this for 
\begin_inset Formula $k=-1$
\end_inset

:
\end_layout

\begin_layout Standard
For 
\begin_inset Formula $i$
\end_inset

 : 
\begin_inset Formula $2\longrightarrow n$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $y_{i}=\frac{1}{b_{i-1}^{*}}\;$
\end_inset

 (
\begin_inset Formula $n$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $b_{i}=b_{i}-y_{i}\;$
\end_inset

(
\begin_inset Formula $n$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\widetilde{b}_{i}=\widetilde{b}_{i}+y_{i}\widetilde{b}_{i-1}\;$
\end_inset

(
\begin_inset Formula $2n$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $\widetilde{b}_{n}=\frac{\widetilde{b}_{n}}{b_{n}}\;(1)$
\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset Formula $i$
\end_inset

 : 
\begin_inset Formula $n-1\longrightarrow1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\widetilde{b}_{i}=\widetilde{b}_{i}+\widetilde{b}_{i+1}\;$
\end_inset

(
\begin_inset Formula $n$
\end_inset

)
\end_layout

\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\widetilde{b}_{i}=\frac{\widetilde{b}_{i}}{b_{i}}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\;$
\end_inset

 (
\begin_inset Formula $n$
\end_inset

)
\end_layout

\begin_layout Standard
This gives a total running time of 
\begin_inset Formula $6n$
\end_inset

 for this implementation of the algorithm, which we ended up using for this
 project.
\end_layout

\begin_layout Standard
<INSERT RESULTS + PLOTS HERE>
\end_layout

\begin_layout Subsection
Exercise c)
\end_layout

\begin_layout Standard
In thie exercise we will compute the relative error in the data set 
\begin_inset Formula $i=1,\dots,n$
\end_inset

,by setting up 
\begin_inset Formula 
\[
\epsilon_{i}=log_{10}\left(\left|\frac{v_{i}-u_{i}}{u_{i}}\right|\right),
\]

\end_inset

as function of 
\begin_inset Formula $log_{10}(h)$
\end_inset

 for the function values 
\begin_inset Formula $u_{i}$
\end_inset

 and 
\begin_inset Formula $v_{i}$
\end_inset

.
 For each step length we will extract the max value of the relative error.
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Subsection
Exercise d)
\end_layout

\begin_layout Standard
(TODO: Change the text below to sound less like an exercise and more like
 a description.)
\end_layout

\begin_layout Standard
Compare your results with those from the LU decomposition codes for the
 matrix of sizes 
\begin_inset Formula $10\times10$
\end_inset

, 
\begin_inset Formula $100\times100$
\end_inset

 and 
\begin_inset Formula $1000\times1000$
\end_inset

.
 Here you should use the library functions provided on the webpage of the
 course.
 Use for example the unix function 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 time
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 when you run your codes and compare the time usage between LU decomposition
 and your tridiagonal solver.
 Alternatively, you can use the functions in C++, Fortran or Python that
 measure the time used.
\end_layout

\begin_layout Standard
Make a table of the results and comment the differences in execution time
 How many floating point operations does the LU decomposition use to solve
 the set of linear equations? Can you run the standard LU decomposition
 for a matrix of the size 
\begin_inset Formula $10^{5}\times10^{5}$
\end_inset

? Comment your results.
\end_layout

\begin_layout Standard
To compute the elapsed time in c++ you can use the following statements
 
\begin_inset listings
lstparams "title={Time in C++}"
inline false
status collapsed

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

#include "time.h"   //  you have to include the time.h header
\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // declarations of variables 
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    clock_t start, finish;  //  declare start and final time
\end_layout

\begin_layout Plain Layout

    start = clock();
\end_layout

\begin_layout Plain Layout

    // your code is here, do something and then get final time
\end_layout

\begin_layout Plain Layout

    finish = clock();
\end_layout

\begin_layout Plain Layout

    ( (finish - start)/CLOCKS_PER_SEC );
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Subsection
Exercise e)
\end_layout

\begin_layout Standard
In this exercise we are investigating matrix multiplication in row major
 order versus column major order with regards to running time.
\end_layout

\begin_layout Standard
The task here is to write a small program which sets up two random (use
 the ran0 function in the library lib.cpp to initialize the matrix) double
 precision valued matrices of dimension 
\begin_inset Formula $5000\times5000$
\end_inset

.
 (NOTE: The original value of 
\begin_inset Formula $10^{4}\times10^{4}$
\end_inset

 proved too memory intensive for our poor laptops.)
\end_layout

\begin_layout Standard
The multiplication of two matrices 
\begin_inset Formula ${\bf A}={\bf BC}$
\end_inset

 could then take the following form in standard row-major order 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstset
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

language=c++
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

      for(j=0 ; j < n ; j++) {
\end_layout

\begin_layout Plain Layout

         for(k=0 ; k < n ; k++) {
\end_layout

\begin_layout Plain Layout

            a[i][j]+=b[i][k]*c[k][j]
\end_layout

\begin_layout Plain Layout

         }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

   }  
\end_layout

\end_inset

 and in a column-major order as 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstset
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

language=c++
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset listings
inline false
status collapsed

\begin_layout Plain Layout

      for(i=0 ; i < n ; i++) {
\end_layout

\begin_layout Plain Layout

         for(k=0 ; k < n ; k++) {
\end_layout

\begin_layout Plain Layout

            a[i][j]+=b[i][k]*c[k][j]
\end_layout

\begin_layout Plain Layout

         }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

   }  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(NOTE: We implemented this using dynamic memory allocation, as lib.cpp proved
 difficult to add to the project in Visual C++.)
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
In this project we learned that...
\end_layout

\begin_layout Subsection
Critique
\end_layout

\begin_layout Standard
We would like to provide the following items of feedback for future versions
 of this project:
\end_layout

\begin_layout Itemize
lib.cpp sucks!
\end_layout

\begin_layout Itemize
we need more RAM.
 you made our laptops feel sad.
\end_layout

\begin_layout Itemize

\end_layout

\end_body
\end_document
